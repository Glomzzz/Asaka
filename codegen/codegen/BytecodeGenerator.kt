package com.skillw.asaka.impl.codegen

import com.skillw.asaka.core.ir.ast.*
import com.skillw.asaka.core.ir.data.Closure
import com.skillw.asaka.core.codegen.CodeGenerator
import com.skillw.asaka.core.error.Err
import com.skillw.asaka.core.ir.ast.ClassCallExpression
import com.skillw.asaka.core.ir.ast.FieldCallExpression
import com.skillw.asaka.core.ir.ast.VarCallExpression
import com.skillw.asaka.core.ir.ast.LiteralExpression
import com.skillw.asaka.core.ir.ast.VoidExpression
import com.skillw.asaka.core.ir.ast.Block
import com.skillw.asaka.core.ir.ast.ClassBlock
import com.skillw.asaka.core.ir.ast.IfStatement
import com.skillw.asaka.core.ir.ast.WhileStatement
import com.skillw.asaka.core.ir.ast.BreakStatement
import com.skillw.asaka.core.ir.ast.ContinueStatement
import com.skillw.asaka.core.ir.ast.ReturnStatement
import com.skillw.asaka.core.ir.ast.FieldDefinition
import com.skillw.asaka.core.ir.ast.MethodDefinition
import com.skillw.asaka.core.ir.ast.VarDefineStatement
import com.skillw.asaka.core.ir.data.*
import com.skillw.asaka.core.ir.member.AsahiParameter
import com.skillw.asaka.core.ir.member.AsahiVariable
import com.skillw.asaka.core.ir.type.AsakaClass
import com.skillw.asaka.core.ir.type.LambdaType
import com.skillw.asaka.core.ir.type.*
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Label
import org.objectweb.asm.MethodVisitor
import org.objectweb.asm.Opcodes.*

class BytecodeGenerator internal constructor(name: String, clazz: String, private val classBlock: ClassBlock) :
    CodeGenerator<Map<String, ByteArray>>(name, clazz) {
    private val writer = ClassWriter(ClassWriter.COMPUTE_FRAMES)
    lateinit var method: MethodVisitor
    private lateinit var address: Address
    private val starts = HashMap<String, Label>()
    private val ends = HashMap<String, Label>()
    private var main = true
    private val methods = hashMapOf<String, MethodInfo>()
    private val fields = hashMapOf<String, AsakaType>()

    private val AsahiVariable.descriptor
        get() = type.confirm().descriptor
    private val AsahiVariable.id: Int
        get() {
            val wide = type.confirm().wide
            return address.address(hashCode(), wide)
        }

    private fun AsahiParameter.id(block: Block): Int {
        val wide = type.confirm().wide
        return address.address(hashcode(block), wide)
    }


    init {
        writer.visit(
            V1_8,
            ACC_PUBLIC or ACC_SUPER or ACC_FINAL,
            internalName,
            null,
            "com/skillw/asaka/core/ModuleBlock",
            null
        )
        writer.visitSource("<generated by AsahiII CodeGen>", null)

        writer.visitField(ACC_PUBLIC or ACC_STATIC or ACC_FINAL, "instance", "L$internalName;", null, null)
    }


    private val init: MethodVisitor =
        writer.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null).apply {
            visitCode()
            visitVarInsn(ALOAD, 0)
            visitLdcInsn(name)
            visitMethodInsn(
                INVOKESPECIAL,
                "com/skillw/asaka/core/ModuleBlock",
                "<init>",
                "(Ljava/lang/String;)V",
                false
            )
            visitVarInsn(ALOAD, 0)
            visitFieldInsn(PUTSTATIC, internalName, "instance", "L$internalName;")
        }


    private inline fun Expression.putValue(rightType: TypeRef, value: () -> Unit) {
        when (this) {

            is FieldCallExpression -> {
                if (!fields.containsKey(name)) Err.syntax("Unknown field: $name (field)", this.source)
                method.loadThis()
                val fieldType = fields[name]!!
                method.autoBox(rightType, fieldType.isBoxed) {
                    value()
                }
                method.visitFieldInsn(PUTFIELD, internalName, name, fieldType.descriptor)
            }

            is VarCallExpression -> {
                val name: String = this.name
                val id = block.variable(this.name)?.id ?: Err.syntax("Unknown variable: $name (unknown)", this.source)
                if (!address.has(id)) Err.syntax("Unknown variable: $name ($id)", this.source)
                val thizType = this.confirmedType()
                method.store(id, thizType) {
                    autoBox(rightType, thizType.isBoxed) {
                        value()
                    }
                }
            }

            else -> {
                Err.syntax("Unsupported expression: $this", this.source)
            }
        }
    }


    private inline fun MethodVisitor.storeRef(id: Int, type: AsakaType, value: MethodVisitor.() -> Unit) {
        address.storeRef(this, id, type, value)
    }

    internal inline fun MethodVisitor.store(id: Int, type: AsakaType, value: MethodVisitor.() -> Unit) {
        address.store(this, id, type, value)
    }

    private fun MethodVisitor.load(id: Int, type: AsakaType) {
        address.load(this, id, type)
    }

    private fun MethodVisitor.loadRaw(id: Int, type: AsakaType) {
        address.loadRaw(this, id, type)
    }

    private fun Expression.isNested() =
        this is VarNestedCallExpression || (this is VarCallExpression && name.contains("\$nested\$"))

    fun code(expr: Expression) {
        when (expr) {
            is LiteralExpression -> if (expr.used) method.const(expr.value)
            is UnaryExpression -> {
                when (expr.operator) {
                    NEG -> {
                        code(expr.target)
                        method.visitInsn(INEG)
                    }

                    NOT -> {
                        code(expr.target)
                        method.visitInsn(ICONST_1)
                        method.visitInsn(IXOR)
                    }

                    POST_INC -> {
                        if (expr.used)
                            code(expr.target)
                        expr.target.putValue(expr.getType()) {
                            code(expr.target)
                            method.visitInsn(ICONST_1)
                            method.visitInsn(IADD)
                        }
                    }

                    POST_DEC -> {
                        if (expr.used)
                            code(expr.target)
                        expr.target.putValue(expr.getType()) {
                            code(expr.target)
                            method.visitInsn(ICONST_1)
                            method.visitInsn(ISUB)
                        }
                    }

                    PRE_INC -> {
                        expr.target.putValue(expr.getType()) {
                            code(expr.target)
                            method.visitInsn(ICONST_1)
                            method.visitInsn(IADD)
                            if (expr.used)
                                method.visitInsn(DUP)
                        }
                    }

                    PRE_DEC -> {
                        expr.target.putValue(expr.getType()) {
                            code(expr.target)
                            method.visitInsn(ICONST_1)
                            method.visitInsn(ISUB)
                            if (expr.used)
                                method.visitInsn(DUP)
                        }
                    }

                    else -> throw UnsupportedOperationException("Unsupported operator: ${expr.operator}")
                }
            }

            is BinaryExpression -> {
                if (expr.result != null) {
                    if (expr.used)
                        method.const(expr.result)
                    return
                }
                if (expr.callSite != null) {
                    method.call(expr.callSite!!, expr.used)
                    if (expr.used && expr.opposite) {
                        method.visitInsn(ICONST_1)
                        method.visitInsn(IXOR)
                    }
                    return
                }
                val op = expr.operator
                val left = expr.left
                val right = expr.right
                when (op) {
                    ASSIGN -> {
                        val nested = left.isNested()
                        val varUsed = if (nested) expr.used else true
                        if (!varUsed) code(right)
                        else
                            left.putValue(right.getType()) {
                                code(right)
                            }
                        if (!nested && expr.used)
                            code(left)
                        return
                    }

                    POW -> {
                        val leftType = left.confirmedType()
                        val rightType = right.confirmedType()
                        code(left)
                        leftType.toD?.let { method.visitInsn(it) }
                        code(right)
                        rightType.toD?.let { method.visitInsn(it) }
                        method.visitMethodInsn(INVOKESTATIC, "java/lang/Math", "pow", "(DD)D", false)
                        if (leftType != A_DOUBLE)
                            method.visitInsn(A_DOUBLE.to(leftType, left.source))
                        return
                    }

                    AS -> {
                        val from = left.confirmedType()
                        val to = right.confirmedType()
                        cast(left, from, to, false)
                        return
                    }

                    IS -> {
                        code(left)
                        val type = right.confirmedType()
                        val clazz = type.internalName
                        method.visitTypeInsn(INSTANCEOF, clazz)
                        return
                    }

                    EQ, NE -> {
                        when {
                            left is LiteralExpression && left.value == null -> {
                                code(right)
                                method.compareNull(op == NE)
                                return
                            }

                            right is LiteralExpression && right.value == null -> {
                                code(left)
                                method.compareNull(op == NE)
                                return
                            }

                            else -> {}
                        }
                    }

                    else -> {
                    }
                }

                method.autoBox(left.getType(), false) {
                    code(left)
                }
                method.autoBox(right.getType(), false) {
                    code(right)
                }
                val type = left.confirmedType().unboxType
                when (op) {
                    ADD -> method.visitInsn(type.add)
                    SUB -> method.visitInsn(type.sub)
                    MUL -> method.visitInsn(type.mul)
                    DIV -> method.visitInsn(type.div)
                    MOD -> method.visitInsn(type.rem)
                    EQ -> method.compare(type, CompareType.EQ)
                    NE -> method.compare(type, CompareType.NE)
                    GT -> method.compare(type, CompareType.GT)
                    LT -> method.compare(type, CompareType.LT)
                    GE -> method.compare(type, CompareType.GE)
                    LE -> method.compare(type, CompareType.LE)

                    AND -> method.visitInsn(IAND)
                    OR -> method.visitInsn(IOR)
                    else -> throw UnsupportedOperationException("Unsupported operator: $op")
                }
            }

            is FieldCallExpression -> method.call(expr.callSite, expr.used)
            is MethodInvokeExpression -> method.call(expr.callSite, expr.used)
            is ObjNewExpression -> method.call(expr.callSite, expr.used)

            is VarCallExpression -> {
                val name = expr.name
                val id = expr.block.variable(name)?.id ?: Err.syntax("Unknown variable: $name", expr.source)
                if (!expr.used) return
                if (address.has(id)) {
                    val type = expr.confirmedType()
                    method.load(id, type)
                } else if (fields.containsKey(name)) {
                    method.loadThis()
                    method.visitFieldInsn(GETFIELD, internalName, name, expr.confirmedType().descriptor)
                } else {
                    Err.syntax("Unknown variable: $name", expr.source)
                }
            }

            is LambdaInvokeExpression -> {
                val type = expr.self.confirmedType() as LambdaType
                method.used(type.returnType, expr.used) {
                    code(expr.self)
                    expr.args.forEach { (_, expr) ->
                        method.autoBox(expr.getType(), true) {
                            code(expr)
                        }
                    }
                    type.info.invoke(method::visitMethodInsn)
                }
            }

            is InvokeExpression -> {
                val invoke = expr.invoke ?: Err.syntax("Unknown invoke: $expr", expr.source)
                code(invoke.apply {
                    box = expr.box
                    used = expr.used
                })
            }

            is LambdaExpression -> {
                if (!expr.used) return
                if (expr.closure()) {
                    expr.closure.code()
                } else {
                    method.ref(expr.refSite)
                }
            }

            is ReferenceExpression -> if (expr.used) method.ref(expr.refSite)
            is ClassCallExpression -> {
                if (expr.confirmedType() is AsakaClass) method.loadThis()
            }

            is VoidExpression -> TODO()
        }
    }

    private fun MethodVisitor.loadThis() {
        if (main)
            visitVarInsn(ALOAD, 0)
        else
            visitFieldInsn(GETSTATIC, internalName, "instance", "L$internalName;")
    }

    private fun code(block: Block) {
        method.visitLineNumber(block.source.line, Label())
        block.nodes.forEach(this::code)
    }

    private fun line(node: Node) {
//        method.visitLineNumber(node.source.line, Label())
    }

    private inline fun label(label: String, start: Label = Label(), end: Label = Label(), todo: () -> Unit) {
        val startCache = starts[label]
        val endCache = ends[label]
        starts[label] = start
        ends[label] = end
        method.visitLabel(start)
        todo()
        method.visitLabel(end)
        startCache?.let { starts[label] = it } ?: starts.remove(label)
        endCache?.let { ends[label] = it } ?: ends.remove(label)
    }


    private fun code(stm: Statement) {
        when (stm) {
            is MethodDefinition -> {
                if (stm.isInline) return
                val name = stm.name
                val descriptor = stm.descriptor
                method = writer.visitMethod(
                    ACC_PUBLIC,
                    name,
                    descriptor,
                    null,
                    null
                )
                line(stm)
                if (!stm.isLambda())
                    methods[name] =
                        MethodInfo(
                            name,
                            descriptor,
                            stm.params.map { it.type.confirm().internalName },
                            stm.confirmedType().internalName
                        )
                intoMethod()
                method.visitCode()
                address = Address(1)
                address.apply {
                    stm.params.forEach {
                        val type = it.type.confirm()
                        address(it.toVar(stm.body).id, !stm.isLambda() && type.wide)
                    }
                }
                stm.body.nodes.forEach(this::code)
                method.visitMaxs(0, 0)
                method.visitEnd()
                outMethod()
            }

            is FieldDefinition -> {
                val name = stm.name
                val value = stm.value
                //字段
                val fieldType = stm.confirmedType()
                val descriptor = fieldType.descriptor
                writer.visitField(
                    ACC_PUBLIC,
                    name,
                    descriptor,
                    null,
                    null
                )
                if (value != null) {
                    method = init
                    method.loadThis()
                    code(value)
                    method.visitFieldInsn(PUTFIELD, internalName, name, descriptor)
                }
                fields[name] = fieldType
            }

            is VarDefineStatement -> {
                if (!stm.used) return
                val name = stm.name
                val variable = stm.block.variable(name) ?: Err.syntax("Unknown variable: $name", stm.source)
                val id = variable.id
                val value = stm.value
                val type = stm.confirmedType()
                val isRef = variable.ref
                if (value != null) {
                    if (isRef) method.storeRef(id, type) { ref(type) { code(value) } }
                    else method.store(id, type) { code(value) }
                } else {
                    method.store(id, type) {
                        const(type.defaultValue)
                    }
                }
            }

            is Block -> {
                line(stm)
                label(stm.labelId) {
                    stm.nodes.forEach(this::code)
                }
            }

            is IfStatement -> {
                line(stm)
                code(stm.condition)
                val skipLabel = Label()
                val elseLabel = Label()
                //将栈顶的值弹出, 如果为 0 则跳转到 elseLabel
                method.visitJumpInsn(IFEQ, elseLabel)
                code(stm.then)
                method.visitJumpInsn(GOTO, skipLabel)
                method.visitLabel(elseLabel)
                stm.otherwise?.let { code(it) }
                method.visitLabel(skipLabel)
            }

            is WhileStatement -> {
                line(stm)
                val start = Label()
                val end = Label()
                val label = stm.body.labelId
                label(label, start, end) {
                    code(stm.condition)
                    method.visitJumpInsn(IFEQ, end)
                    code(stm.body)
                    method.visitJumpInsn(GOTO, start)
                }
            }

            is BreakStatement -> {
                line(stm)
                method.visitJumpInsn(GOTO, ends[stm.labelId])
            }

            is ContinueStatement -> {
                line(stm)
                method.visitJumpInsn(GOTO, starts[stm.labelId])
            }

            is ReturnStatement -> {
                line(stm)
                val value = stm.value
                val rtnType = stm.getType().confirm()
                if (value is VoidExpression && stm.block.method().inline) {
                    method.visitJumpInsn(GOTO, ends[stm.block.labelId])
                    return
                }
                if (value !is VoidExpression) {
                    method.autoBox(value.getType(), rtnType.isBoxed) { code(value) }
                    if (rtnType.isBoxed)
                        method.visitTypeInsn(CHECKCAST, rtnType.internalName)
                }
                method.visitInsn(rtnType.rtn)
            }

            else -> throw UnsupportedOperationException("Unsupported statement: $stm")
        }
    }

    private fun prologue() {}
    private fun code(node: Node) {
        when (node) {
            is Statement -> code(node)
            is Expression -> code(node)
        }
    }

    data class MethodInfo(val name: String, val descriptor: String, val paramTypes: List<String>, val rtn: String)

    private fun epilogue() {
        method = init
        classBlock.init.nodes.forEach(this::code)
        init.visitInsn(RETURN)
        init.visitMaxs(0, 0)
        init.visitEnd()
        writer.visitMethod(
            ACC_PUBLIC,
            "invoke",
            "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/Object;",
            null,
            null
        ).apply {
            val defaultLabel = Label()
            val labelMap = LinkedHashMap<Label, String>()
            for (methodName in methods.keys) {
                val caseLabel = Label()
                labelMap[caseLabel] = methodName
            }
            visitCode()
            visitVarInsn(ALOAD, 1)
            visitMethodInsn(INVOKEVIRTUAL, "java/lang/String", "hashCode", "()I", false)
            val map = labelMap.map { it.key to it.value.hashCode() }.sortedWith(compareBy { it.second })
            visitLookupSwitchInsn(
                defaultLabel,
                map.map { it.second }.toIntArray(),
                map.map { it.first }.toTypedArray()
            )

            for (caseLabel in labelMap.keys) {
                visitLabel(caseLabel)
                val method = labelMap[caseLabel]
                val (_, descriptor, params, rtn) = methods[method] as MethodInfo
                boxing(rtn) {
                    // 加载this
                    loadThis()
                    // 分开加载参数
                    for (index in params.indices) {
                        // 加载 args : Object[]
                        visitVarInsn(ALOAD, 2)
                        val type = params[index]
                        //拆箱 真捏码无语了sb JVM
                        unboxing(type) {
                            const(index)
                            visitInsn(AALOAD)
                        }
                    }
                    visitMethodInsn(INVOKEVIRTUAL, internalName, method, descriptor, false)
                }
                if (rtn == "V")
                    visitInsn(ACONST_NULL)
                visitInsn(ARETURN)
            }

            // 所有 case 都未匹配成功，执行默认逻辑
            visitLabel(defaultLabel)
            visitTypeInsn(NEW, "java/lang/IllegalArgumentException")
            visitInsn(DUP)
            visitLdcInsn("Method not found")
            visitMethodInsn(
                INVOKESPECIAL,
                "java/lang/IllegalArgumentException",
                "<init>",
                "(Ljava/lang/String;)V",
                false
            )
            visitInsn(ATHROW)
            visitInsn(RETURN)
            visitMaxs(0, 0)
            visitEnd()
        }
        writer.visitEnd()

        bytecodes[clazz] = writer.toByteArray()
    }

    private val bytecodes = hashMapOf<String, ByteArray>()

    override fun generate(): Map<String, ByteArray> {
        //main
        prologue()
        classBlock.allNodes.forEach(this::code)
        epilogue()

        //total
        return bytecodes
    }


    private fun codeSelf(self: Expression) {
        if (self is ClassCallExpression) {
            if (self.confirmedType() is AsakaClass) method.loadThis()
        } else {
            code(self)
        }
    }

    private fun MethodVisitor.call(callSite: CallSite, used: Boolean) {
        when (callSite) {
            is MethodCallSite -> call(callSite, used)
            is FieldCallSite -> call(callSite, used)
            is FieldPutSite -> call(callSite, used)
        }
    }

    private fun MethodVisitor.call(callSite: FieldCallSite, used: Boolean) {
        if (!used) return
        val (self, name, type, static, source) = callSite
        val descriptor = type.descriptor
        val clazz = source.internalName
        if (!static)
            codeSelf(self)
        val opcode = if (static) GETSTATIC else GETFIELD
        visitFieldInsn(opcode, clazz, name, descriptor)
    }

    private fun MethodVisitor.call(putSite: FieldPutSite, used: Boolean) {
        val (self, name, type, static, value, source) = putSite
        val descriptor = type.descriptor
        val clazz = source.internalName
        if (!static)
            codeSelf(self)
        code(value)
        val opcode = if (static) PUTSTATIC else PUTFIELD
        visitFieldInsn(opcode, clazz, name, descriptor)
        if (used) {
            val get = if (static) GETSTATIC else GETFIELD
            visitFieldInsn(get, clazz, name, descriptor)
        }
    }

    private fun MethodVisitor.call(callSite: MethodCallSite, used: Boolean) {
        val (self, name, paramTypes, args, _, static, source, isInterface) = callSite
        val descriptor = callSite.descriptor
        val clazz = source.internalName.self(internalName)
        used(callSite.returnType, used) {
            val new = callSite.name == "<init>"
            if (new) {
                method.visitTypeInsn(NEW, clazz)
                method.visitInsn(DUP)
            } else if (!static) codeSelf(self)
            args.forEachIndexed { index, expr ->
                autoBox(expr.getType(), paramTypes[index].confirm().isBoxed) {
                    code(expr)
                }
            }
            if (new) {
                if (used)
                    method.visitMethodInsn(INVOKESPECIAL, clazz, "<init>", descriptor, false)
                return
            }
            val opcode = if (static) INVOKESTATIC else if (isInterface) INVOKEINTERFACE else INVOKEVIRTUAL
            visitMethodInsn(opcode, clazz, name, descriptor, isInterface)
        }
    }


    private fun Closure.code() {
        val writer = ClassWriter(ClassWriter.COMPUTE_FRAMES)
        val name = "$internalName\$$name"
        writer.visit(
            V1_8,
            ACC_PUBLIC + ACC_SUPER + ACC_STATIC,
            name,
            null,
            "java/lang/Object",
            Array(1) { funInterface }
        )

        val constructor = StringBuilder("(")
        fields.forEach {
            val descriptor = it.descriptor
            writer.visitField(ACC_PRIVATE, it.name, descriptor, null, null)
            constructor.append(descriptor)
        }
        constructor.append(")V")

        writer.visitMethod(ACC_PUBLIC, "<init>", constructor.toString(), null, null).apply {
            visitCode()
            visitVarInsn(ALOAD, 0)
            visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false)
            fields.forEachIndexed { index, field ->
                val type = field.type.confirm()
                visitVarInsn(ALOAD, 0)
                visitVarInsn(if (field.ref) ALOAD else type.load, index + 1)
                visitFieldInsn(PUTFIELD, name, field.name, field.descriptor)
            }
            visitInsn(RETURN)
            visitMaxs(0, 0)
            visitEnd()
        }

        val temp1 = address
        address = Address(1)
        val temp2 = method
        main = false
        method = writer.visitMethod(ACC_PUBLIC, methodName, methodDescriptor, null, null)
        method.apply {
            visitCode()
            params.forEach {
                address.address(it.id(body), it.type.confirm().wide)
            }
            fields.forEachIndexed { _, field ->
                val type = field.type.confirm()
                if (field.ref)
                    storeRef(field.id, type) {
                        visitVarInsn(ALOAD, 0)
                        visitFieldInsn(GETFIELD, name, field.name, field.descriptor)
                    }
                else
                    store(field.id, type) {
                        visitVarInsn(ALOAD, 0)
                        visitFieldInsn(GETFIELD, name, field.name, field.descriptor)
                    }
            }
            body.nodes.forEach(this@BytecodeGenerator::code)
            visitMaxs(0, 0)
            visitEnd()
        }
        writer.visitEnd()
        bytecodes[name.replace('/', '.')] = writer.toByteArray()
        address = temp1
        method = temp2
        main = true

        method.visitTypeInsn(NEW, name)
        method.visitInsn(DUP)
        fields.forEach {
            val type = it.type.confirm()
            method.loadRaw(it.id, type)
            method.visitTypeInsn(CHECKCAST, type.internalName)
        }
        method.visitMethodInsn(INVOKESPECIAL, name, "<init>", constructor.toString(), false)
    }

    internal fun MethodVisitor.ref(refSite: RefSite): FunctionLinker {
        val info = when (refSite) {
            is FieldRefSite -> function(0, false) ?: Err.syntax(
                "Unsupported function: 0 -> void",
                refSite.self.source
            )

            is MethodRefSite -> function(refSite.paramTypes.size, refSite.returnType.void()) ?: Err.syntax(
                "Unsupported function: ${refSite.paramTypes.size} -> ${refSite.returnType}",
                refSite.self.source
            )
        }
        if (!refSite.static)
            codeSelf(refSite.self)
        val methodHandle = info.generateHandle(refSite, clazz)
        val methodType = info.generateType(refSite)
        visitInvokeDynamicInsn(
            info.method,
            info.descriptor("L${refSite.source.internalName.self(internalName)};"),
            commonHandle(),
            info.asmType,
            methodHandle,
            methodType,
        )
        return info
    }


}
